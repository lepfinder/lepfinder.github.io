{"meta":{"title":"XiXi's Blog","subtitle":"让一切慢下来，体验周边的美好","description":null,"author":"XiYang","url":"http://yoursite.com"},"pages":[{"title":"个人项目","date":"2017-09-14T01:30:29.000Z","updated":"2017-09-14T01:58:06.000Z","comments":true,"path":"project/index.html","permalink":"http://yoursite.com/project/index.html","excerpt":"","text":"代码生成器DBMasterKnightWukong"},{"title":"分类","date":"2017-09-14T01:37:51.000Z","updated":"2017-09-14T01:40:55.000Z","comments":false,"path":"categories/index.html","permalink":"http://yoursite.com/categories/index.html","excerpt":"","text":""},{"title":"tags","date":"2017-09-14T01:41:48.000Z","updated":"2017-09-14T01:42:05.000Z","comments":true,"path":"tags/index.html","permalink":"http://yoursite.com/tags/index.html","excerpt":"","text":""},{"title":"关于我","date":"2017-09-14T01:22:03.000Z","updated":"2017-09-14T01:56:26.000Z","comments":true,"path":"about/index.html","permalink":"http://yoursite.com/about/index.html","excerpt":"","text":"Name &amp; 联系方式 name：解西扬 telPhone：13220100526 qq：80381107 经历 2007-2011 山东理工大学 2011-2013 北大方正电子科技有限公司 2013-2014 百度糯米 2014至今 北京千丁互联科技有限公司 专注于 java 领域开发，对分布式系统开发和设计有一定的经验，主导设计开发过当前公司的订单、促销、商城、支付、财务结算和风控等系统。 擅于总结，创造轮子，提供了一些效率工具，比如代码生成器、集中式导出服务、通用监控报警平台等。"}],"posts":[{"title":"ArrayList 和 Vector 的区别","slug":"05-java集合类之 ArrayList 和 Vector 的区别","date":"2017-09-12T04:08:58.000Z","updated":"2017-09-12T10:26:34.000Z","comments":true,"path":"2017/09/12/05-java集合类之 ArrayList 和 Vector 的区别/","link":"","permalink":"http://yoursite.com/2017/09/12/05-java集合类之 ArrayList 和 Vector 的区别/","excerpt":"","text":"1. Synchronization and Thread-SafeVector is synchronized while ArrayList is not synchronized . Synchronization and thread safe means at a time only one thread can access the code .In Vector class all the methods are synchronized .Thats why the Vector object is already synchronized when it is created . 2. PerformanceVector is slow as it is thread safe . In comparison ArrayList is fast as it is non synchronized . Thus in ArrayList two or more threads can access the code at the same time , while Vector is limited to one thread at a time. 3. Automatic Increase in CapacityA Vector defaults to doubling size of its array . While when you insert an element into the ArrayList , it increasesits Array size by 50% . By default ArrayList size is 10 . It checks whether it reaches the last element then it will create the new array ,copy the new data of last array to new array ,then old array is garbage collected by the Java Virtual Machine (JVM) . 4. Set Increment SizeArrayList does not define the increment size . Vector defines the increment size . You can find the following method in Vector Class public synchronized void setSize(int i) { //some code } There is no setSize() method or any other method in ArrayList which can manually set the increment size. 5. EnumeratorOther than Hashtable ,Vector is the only other class which uses both Enumeration and Iterator .While ArrayList can only use Iterator for traversing an ArrayList . 6. Introduction in Javajava.util.Vector class was there in java since the very first version of the java development kit (jdk).java.util.ArrayList was introduced in java version 1.2 , as part of Java Collections framework . In java version 1.2 , Vector class has been refactored to implement the List Inteface .","categories":[],"tags":[]},{"title":"LinkedList介绍","slug":"03-java集合类之LinkedList","date":"2017-09-12T02:54:35.000Z","updated":"2017-09-14T01:49:43.000Z","comments":true,"path":"2017/09/12/03-java集合类之LinkedList/","link":"","permalink":"http://yoursite.com/2017/09/12/03-java集合类之LinkedList/","excerpt":"","text":"LinkedList简介 LinkedList 是一个继承于AbstractSequentialList的双向链表。它也可以被当作堆栈、队列或双端队列进行操作。 LinkedList 实现 List 接口，能对它进行队列操作。 LinkedList 实现 Deque 接口，即能将LinkedList当作双端队列使用。 LinkedList 实现了Cloneable接口，即覆盖了函数clone()，能克隆。 LinkedList 实现java.io.Serializable接口，这意味着LinkedList支持序列化，能通过序列化去传输。 LinkedList 是非同步的。 类声明123public class LinkedList&lt;E&gt; extends AbstractSequentialList&lt;E&gt; implements List&lt;E&gt;, Deque&lt;E&gt;, Cloneable, java.io.Serializable 类继承关系图 构造函数1234567public LinkedList() &#123;&#125;public LinkedList(Collection&lt;? extends E&gt; c) &#123; this(); addAll(c);&#125; 数据结构123456789101112131415161718192021222324transient int size = 0;/** * Pointer to first node. */transient Node&lt;E&gt; first;/** * Pointer to last node. */transient Node&lt;E&gt; last;private static class Node&lt;E&gt; &#123; E item; Node&lt;E&gt; next; Node&lt;E&gt; prev; Node(Node&lt;E&gt; prev, E element, Node&lt;E&gt; next) &#123; this.item = element; this.next = next; this.prev = prev; &#125;&#125; 重要方法实现add12345678910111213141516171819public boolean add(E e) &#123; linkLast(e); return true;&#125;/** * Links e as last element. */void linkLast(E e) &#123; final Node&lt;E&gt; l = last; final Node&lt;E&gt; newNode = new Node&lt;&gt;(l, e, null); last = newNode; if (l == null) first = newNode; else l.next = newNode; size++; modCount++;&#125; 新加入的元素会变为最后一个元素，如果是第一次添加，也就是last==null，则first==last==newNode get1234567891011121314151617181920public E get(int index) &#123; checkElementIndex(index); return node(index).item;&#125;Node&lt;E&gt; node(int index) &#123; // assert isElementIndex(index); if (index &lt; (size &gt;&gt; 1)) &#123; //检查index是否小于集合大小的半，来决定是从头查找还是从尾部查找 Node&lt;E&gt; x = first; for (int i = 0; i &lt; index; i++) x = x.next; return x; &#125; else &#123; Node&lt;E&gt; x = last; for (int i = size - 1; i &gt; index; i--) x = x.prev; return x; &#125;&#125; 在LinkedList中获取指定位置的一个元素需要挨个遍历，jdk做了简单的一个优化，首先判断index是否小于集合大小的半，来决定是从头查找还是从尾部查找，这样可以减少遍历的次数。 队列的操作12345678910//获取一个元素，不删除public E peek() &#123; final Node&lt;E&gt; f = first; return (f == null) ? null : f.item;&#125;//从头获取一个元素，同时删除此元素public E poll() &#123; final Node&lt;E&gt; f = first; return (f == null) ? null : unlinkFirst(f);&#125;","categories":[],"tags":[]},{"title":"ArrayList","slug":"03-java集合类之ArrayList","date":"2017-09-11T09:33:37.000Z","updated":"2017-09-14T01:51:12.000Z","comments":true,"path":"2017/09/11/03-java集合类之ArrayList/","link":"","permalink":"http://yoursite.com/2017/09/11/03-java集合类之ArrayList/","excerpt":"","text":"概述ArrayList 是一个数组队列，相当于 动态数组。与Java中的数组相比，它的容量能动态增长。它继承于AbstractList，实现了List, RandomAccess, Cloneable, java.io.Serializable这些接口。 ArrayList 继承了AbstractList，实现了List。它是一个数组队列，提供了相关的添加、删除、修改、遍历等功能。ArrayList 实现了RandmoAccess接口，即提供了随机访问功能。RandmoAccess是java中用来被List实现，为List提供快速访问功能的。在ArrayList中，我们即可以通过元素的序号快速获取元素对象；这就是快速随机访问。稍后，我们会比较List的“快速随机访问”和“通过Iterator迭代器访问”的效率。 ArrayList 实现了Cloneable接口，即覆盖了函数clone()，能被克隆。 ArrayList 实现java.io.Serializable接口，这意味着ArrayList支持序列化，能通过序列化去传输。 和Vector不同，ArrayList中的操作不是线程安全的！所以，建议在单线程中才使用ArrayList，而在多线程中可以选择Vector或者CopyOnWriteArrayList。 ArrayList 构造函数12345678// 默认构造函数ArrayList()// capacity是ArrayList的默认容量大小。当由于增加数据导致容量不足时，容量会添加上一次容量大小的一半。ArrayList(int capacity)// 创建一个包含collection的ArrayListArrayList(Collection&lt;? extends E&gt; collection) ArrayList 类图结构如下 源码解析ArrayList 中有两个重要的变量 private transient Object[] elementData; elementData 是一个Object的数组，JDK 实现了一个动态数组，可以动态的增加数组的大小，初始的大小是10。 private int size; size 标示了动态数组的实际大小 构造函数：1234567891011121314151617181920212223242526272829/** * 创建一个指定容量大小的空数组 */public ArrayList(int initialCapacity) &#123; super(); if (initialCapacity &lt; 0) throw new IllegalArgumentException(\"Illegal Capacity: \"+ initialCapacity); this.elementData = new Object[initialCapacity];&#125;/** * 创建一个空数组 */public ArrayList() &#123; super(); this.elementData = EMPTY_ELEMENTDATA;&#125;/** * 创建一个包含传递进来的元素的数组 */public ArrayList(Collection&lt;? extends E&gt; c) &#123; elementData = c.toArray(); size = elementData.length; // c.toArray might (incorrectly) not return Object[] (see 6260652) if (elementData.getClass() != Object[].class) elementData = Arrays.copyOf(elementData, size, Object[].class);&#125; add方法的实现 12345678910111213141516171819202122232425262728293031323334353637383940414243// 添加一个元素public boolean add(E e) &#123; ensureCapacityInternal(size + 1); // Increments modCount!! elementData[size++] = e; return true;&#125;// 确定容量private void ensureCapacityInternal(int minCapacity) &#123; if (elementData == EMPTY_ELEMENTDATA) &#123; minCapacity = Math.max(DEFAULT_CAPACITY, minCapacity); &#125; ensureExplicitCapacity(minCapacity);&#125;private void ensureExplicitCapacity(int minCapacity) &#123; modCount++; // overflow-conscious code if (minCapacity - elementData.length &gt; 0) grow(minCapacity);&#125;private void grow(int minCapacity) &#123; // overflow-conscious code int oldCapacity = elementData.length; int newCapacity = oldCapacity + (oldCapacity &gt;&gt; 1); if (newCapacity - minCapacity &lt; 0) newCapacity = minCapacity; if (newCapacity - MAX_ARRAY_SIZE &gt; 0) newCapacity = hugeCapacity(minCapacity); // minCapacity is usually close to size, so this is a win: elementData = Arrays.copyOf(elementData, newCapacity);&#125;private static int hugeCapacity(int minCapacity) &#123; if (minCapacity &lt; 0) // overflow throw new OutOfMemoryError(); return (minCapacity &gt; MAX_ARRAY_SIZE) ? Integer.MAX_VALUE : MAX_ARRAY_SIZE;&#125; ArrayList 默认的构造函数，创建的是一个空数组，是在第一次添加对象的时候做的初始化。 添加元素的时候如果容量不足，会进行扩容，新的容量会之前的1.5倍 最大的容量为 Integer.MAX_VALUE 遍历的三种方式ArrayList支持3种遍历方式 (01) 第一种，通过迭代器遍历。即通过Iterator去遍历。 12345Integer value = null;Iterator iter = list.iterator();while (iter.hasNext()) &#123; value = (Integer)iter.next();&#125; (02) 第二种，随机访问，通过索引值去遍历。由于ArrayList实现了RandomAccess接口，它支持通过索引值去随机访问元素。 12345Integer value = null;int size = list.size();for (int i=0; i&lt;size; i++) &#123; value = (Integer)list.get(i); &#125; (03) 第三种，for循环遍历。如下： 1234Integer value = null;for (Integer integ:list) &#123; value = integ;&#125; ConcurrentModificationExceptionAbstractList 中有一个成员变量 modCount, 记录了数据在结构上变化的次数，比如添加或删除一个元素的次数12// The number of times this list has been structurally modifiedprotected transient int modCount = 0; 在Java中的fail-fast机制中有介绍过。在使用迭代器遍历元素的时候，在对集合进行删除的时候一定要注意，使用不当有可能发生ConcurrentModificationException。","categories":[],"tags":[]},{"title":"Collection 架构","slug":"02-java集合类之Collection 架构","date":"2017-09-07T09:52:03.000Z","updated":"2017-09-12T10:26:39.000Z","comments":true,"path":"2017/09/07/02-java集合类之Collection 架构/","link":"","permalink":"http://yoursite.com/2017/09/07/02-java集合类之Collection 架构/","excerpt":"","text":"概要首先看一下 Collection 的类图结构如下： Collection 是一个接口，它主要有两个分支 List 和 Set。 List 和 Set 是两个接口，他们继承自 Collection ，List 是有序的队列，元素可以重复， Set 是不重复的的集合。 为了减少重复代码，jdk 抽象出了一个 AbstractCollection 抽象类，这个类实现了 Collection 中绝大部分函数，这样在其它的实现类中就可以省去重复的编码。 AbstractList 和 AbstractSet都继承于AbstractCollection，具体的List实现类继承于AbstractList，而Set的实现类则继承于AbstractSet。 Collection 类详解Collection 的定义如下：1public interface Collection&lt;E&gt; extends Iterable&lt;E&gt; &#123; 包含的方法如下： List 详解接口声明： 1public interface List&lt;E&gt; extends Collection&lt;E&gt; &#123; 包含的方法： ![](image:: http://7xo9p3.com1.z0.glb.clouddn.com/markdown/1505118343539.png?imageMogr2/thumbnail/!100p/quality/100!） 其中带 上箭头 是从 Collection 继承来的，相比于 Collection ，主要增加了一些在指定位置添加、删除、修改、获取对应元素的接口。还有获取List中的子队列。 Set 详解接口声明 1public interface Set&lt;E&gt; extends Collection&lt;E&gt; &#123; 包含的方法： 关于API方面。Set的API和Collection完全一样。","categories":[],"tags":[{"name":"java","slug":"java","permalink":"http://yoursite.com/tags/java/"}]},{"title":"HashMap","slug":"06-深入研究java基础---HashMap","date":"2016-10-21T10:12:53.000Z","updated":"2017-09-12T09:45:57.000Z","comments":true,"path":"2016/10/21/06-深入研究java基础---HashMap/","link":"","permalink":"http://yoursite.com/2016/10/21/06-深入研究java基础---HashMap/","excerpt":"","text":"概述123public class HashMap&lt;K,V&gt; extends AbstractMap&lt;K,V&gt; implements Map&lt;K,V&gt;, Cloneable, Serializable 类图结构 http://yikun.github.io/2015/04/01/Java-HashMap%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86%E5%8F%8A%E5%AE%9E%E7%8E%B0/ http://www.cnblogs.com/skywang12345/p/3323085.html","categories":[],"tags":[]},{"title":"java集合类概述","slug":"01-java集合类概述","date":"2016-08-05T03:58:13.000Z","updated":"2017-09-12T09:42:51.000Z","comments":true,"path":"2016/08/05/01-java集合类概述/","link":"","permalink":"http://yoursite.com/2016/08/05/01-java集合类概述/","excerpt":"","text":"在java中一切皆是对象，集合就是盛放对象的容器，根据不同的数据结构（集合、链表、队列、栈、数组、映射等）对应不同的集合类。java的集合类都在java.util包下。为了处理多线程环境下的并发安全问题，java5还在java.util.concurrent包下提供了一些多线程支持的集合类。本文暂不包含并发集合包。 java 集合主要可以分为如下4个部分：List列表、Set集合、Map映射和工具类（Iterator迭代器、Enumeration枚举类、Arrays和Collections）。如下图所示： 整体的框架图如下： 梳理出主干我们常用的集合类如下： 最主要的两个接口 Collection 和 Map 1 、 Collections 包含了 List 和 Set 两种不同的数据集合。 List 是一个有序的队列，包含了常用的 ArrayList，LinkedList、Vector和Stack 类。 Set 是一个不允许重复元素的集合，包含有 HashSet、TreeSet。HashSet依赖于HashMap，TreeSet依赖于TreeMap 2、 Map 是表示键值对映射的结构。 AbstractMap 是一个抽象类，它实现了Map接口中的大部分API，而HashMap、TreeMap、WeakHashMap都是继承于AbstractMap。HashTable继承于Dictionary，但它实现了Map接口。 Arrays 和 Collections 是两个常用的工具类。","categories":[],"tags":[]}]}