{"meta":{"title":"XiYang's Blog","subtitle":"让一切慢下来，体验周边的美好","description":null,"author":"XiYang","url":"http://yoursite.com"},"pages":[{"title":"个人项目","date":"2017-09-14T01:30:29.000Z","updated":"2017-09-14T01:58:06.000Z","comments":true,"path":"project/index.html","permalink":"http://yoursite.com/project/index.html","excerpt":"","text":"代码生成器DBMasterKnightWukong"},{"title":"分类","date":"2017-09-14T01:37:51.000Z","updated":"2017-09-14T01:40:55.000Z","comments":false,"path":"categories/index.html","permalink":"http://yoursite.com/categories/index.html","excerpt":"","text":""},{"title":"关于我","date":"2017-09-14T01:22:03.000Z","updated":"2017-09-14T01:56:26.000Z","comments":true,"path":"about/index.html","permalink":"http://yoursite.com/about/index.html","excerpt":"","text":"Name &amp; 联系方式 name：解西扬 telPhone：13220100526 qq：80381107 经历 2007-2011 山东理工大学 2011-2013 北大方正电子科技有限公司 2013-2014 百度糯米 2014至今 北京千丁互联科技有限公司 专注于 java 领域开发，对分布式系统开发和设计有一定的经验，主导设计开发过当前公司的订单、促销、商城、支付、财务结算和风控等系统。 擅于总结，创造轮子，提供了一些效率工具，比如代码生成器、集中式导出服务、通用监控报警平台等。"},{"title":"tags","date":"2017-09-14T01:41:48.000Z","updated":"2017-09-14T01:42:05.000Z","comments":true,"path":"tags/index.html","permalink":"http://yoursite.com/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"ArrayList 和 Vector 的区别","slug":"05-java集合类之 ArrayList 和 Vector 的区别","date":"2017-09-12T04:08:58.000Z","updated":"2017-09-14T08:31:41.000Z","comments":true,"path":"2017/09/12/05-java集合类之 ArrayList 和 Vector 的区别/","link":"","permalink":"http://yoursite.com/2017/09/12/05-java集合类之 ArrayList 和 Vector 的区别/","excerpt":"","text":"1. Synchronization and Thread-SafeVector is synchronized while ArrayList is not synchronized . Synchronization and thread safe means at a time only one thread can access the code .In Vector class all the methods are synchronized .Thats why the Vector object is already synchronized when it is created . 2. PerformanceVector is slow as it is thread safe . In comparison ArrayList is fast as it is non synchronized . Thus in ArrayList two or more threads can access the code at the same time , while Vector is limited to one thread at a time. 3. Automatic Increase in CapacityA Vector defaults to doubling size of its array . While when you insert an element into the ArrayList , it increasesits Array size by 50% . By default ArrayList size is 10 . It checks whether it reaches the last element then it will create the new array ,copy the new data of last array to new array ,then old array is garbage collected by the Java Virtual Machine (JVM) . 4. Set Increment SizeArrayList does not define the increment size . Vector defines the increment size . You can find the following method in Vector Class public synchronized void setSize(int i) { //some code } There is no setSize() method or any other method in ArrayList which can manually set the increment size. 5. EnumeratorOther than Hashtable ,Vector is the only other class which uses both Enumeration and Iterator .While ArrayList can only use Iterator for traversing an ArrayList . 6. Introduction in Javajava.util.Vector class was there in java since the very first version of the java development kit (jdk).java.util.ArrayList was introduced in java version 1.2 , as part of Java Collections framework . In java version 1.2 , Vector class has been refactored to implement the List Inteface .","categories":[{"name":"java 集合","slug":"java-集合","permalink":"http://yoursite.com/categories/java-集合/"}],"tags":[{"name":"java","slug":"java","permalink":"http://yoursite.com/tags/java/"}]},{"title":"LinkedList 详解和源码解析","slug":"03-java集合类之LinkedList","date":"2017-09-12T02:54:35.000Z","updated":"2017-09-14T08:31:57.000Z","comments":true,"path":"2017/09/12/03-java集合类之LinkedList/","link":"","permalink":"http://yoursite.com/2017/09/12/03-java集合类之LinkedList/","excerpt":"","text":"LinkedList简介 LinkedList 是一个继承于AbstractSequentialList的双向链表。它也可以被当作堆栈、队列或双端队列进行操作。 LinkedList 实现 List 接口，能对它进行队列操作。 LinkedList 实现 Deque 接口，即能将LinkedList当作双端队列使用。 LinkedList 实现了Cloneable接口，即覆盖了函数clone()，能克隆。 LinkedList 实现java.io.Serializable接口，这意味着LinkedList支持序列化，能通过序列化去传输。 LinkedList 是非同步的。 类声明123public class LinkedList&lt;E&gt; extends AbstractSequentialList&lt;E&gt; implements List&lt;E&gt;, Deque&lt;E&gt;, Cloneable, java.io.Serializable 类继承关系图 构造函数1234567public LinkedList() &#123;&#125;public LinkedList(Collection&lt;? extends E&gt; c) &#123; this(); addAll(c);&#125; 数据结构123456789101112131415161718192021222324transient int size = 0;/** * Pointer to first node. */transient Node&lt;E&gt; first;/** * Pointer to last node. */transient Node&lt;E&gt; last;private static class Node&lt;E&gt; &#123; E item; Node&lt;E&gt; next; Node&lt;E&gt; prev; Node(Node&lt;E&gt; prev, E element, Node&lt;E&gt; next) &#123; this.item = element; this.next = next; this.prev = prev; &#125;&#125; 重要方法实现add12345678910111213141516171819public boolean add(E e) &#123; linkLast(e); return true;&#125;/** * Links e as last element. */void linkLast(E e) &#123; final Node&lt;E&gt; l = last; final Node&lt;E&gt; newNode = new Node&lt;&gt;(l, e, null); last = newNode; if (l == null) first = newNode; else l.next = newNode; size++; modCount++;&#125; 新加入的元素会变为最后一个元素，如果是第一次添加，也就是last==null，则first==last==newNode get1234567891011121314151617181920public E get(int index) &#123; checkElementIndex(index); return node(index).item;&#125;Node&lt;E&gt; node(int index) &#123; // assert isElementIndex(index); if (index &lt; (size &gt;&gt; 1)) &#123; //检查index是否小于集合大小的半，来决定是从头查找还是从尾部查找 Node&lt;E&gt; x = first; for (int i = 0; i &lt; index; i++) x = x.next; return x; &#125; else &#123; Node&lt;E&gt; x = last; for (int i = size - 1; i &gt; index; i--) x = x.prev; return x; &#125;&#125; 在LinkedList中获取指定位置的一个元素需要挨个遍历，jdk做了简单的一个优化，首先判断index是否小于集合大小的半，来决定是从头查找还是从尾部查找，这样可以减少遍历的次数。 队列的操作12345678910//获取一个元素，不删除public E peek() &#123; final Node&lt;E&gt; f = first; return (f == null) ? null : f.item;&#125;//从头获取一个元素，同时删除此元素public E poll() &#123; final Node&lt;E&gt; f = first; return (f == null) ? null : unlinkFirst(f);&#125;","categories":[{"name":"java 集合","slug":"java-集合","permalink":"http://yoursite.com/categories/java-集合/"}],"tags":[{"name":"java","slug":"java","permalink":"http://yoursite.com/tags/java/"}]},{"title":"ArrayList 详解和源码解析","slug":"03-java集合类之ArrayList","date":"2017-09-11T09:33:37.000Z","updated":"2017-09-14T08:32:00.000Z","comments":true,"path":"2017/09/11/03-java集合类之ArrayList/","link":"","permalink":"http://yoursite.com/2017/09/11/03-java集合类之ArrayList/","excerpt":"","text":"概述ArrayList 是一个数组队列，相当于 动态数组。与Java中的数组相比，它的容量能动态增长。它继承于AbstractList，实现了List, RandomAccess, Cloneable, java.io.Serializable这些接口。 ArrayList 继承了AbstractList，实现了List。它是一个数组队列，提供了相关的添加、删除、修改、遍历等功能。ArrayList 实现了RandmoAccess接口，即提供了随机访问功能。RandmoAccess是java中用来被List实现，为List提供快速访问功能的。在ArrayList中，我们即可以通过元素的序号快速获取元素对象；这就是快速随机访问。稍后，我们会比较List的“快速随机访问”和“通过Iterator迭代器访问”的效率。 ArrayList 实现了Cloneable接口，即覆盖了函数clone()，能被克隆。 ArrayList 实现java.io.Serializable接口，这意味着ArrayList支持序列化，能通过序列化去传输。 和Vector不同，ArrayList中的操作不是线程安全的！所以，建议在单线程中才使用ArrayList，而在多线程中可以选择Vector或者CopyOnWriteArrayList。 ArrayList 构造函数12345678// 默认构造函数ArrayList()// capacity是ArrayList的默认容量大小。当由于增加数据导致容量不足时，容量会添加上一次容量大小的一半。ArrayList(int capacity)// 创建一个包含collection的ArrayListArrayList(Collection&lt;? extends E&gt; collection) ArrayList 类图结构如下 源码解析ArrayList 中有两个重要的变量 private transient Object[] elementData; elementData 是一个Object的数组，JDK 实现了一个动态数组，可以动态的增加数组的大小，初始的大小是10。 private int size; size 标示了动态数组的实际大小 构造函数：1234567891011121314151617181920212223242526272829/** * 创建一个指定容量大小的空数组 */public ArrayList(int initialCapacity) &#123; super(); if (initialCapacity &lt; 0) throw new IllegalArgumentException(\"Illegal Capacity: \"+ initialCapacity); this.elementData = new Object[initialCapacity];&#125;/** * 创建一个空数组 */public ArrayList() &#123; super(); this.elementData = EMPTY_ELEMENTDATA;&#125;/** * 创建一个包含传递进来的元素的数组 */public ArrayList(Collection&lt;? extends E&gt; c) &#123; elementData = c.toArray(); size = elementData.length; // c.toArray might (incorrectly) not return Object[] (see 6260652) if (elementData.getClass() != Object[].class) elementData = Arrays.copyOf(elementData, size, Object[].class);&#125; add方法的实现 12345678910111213141516171819202122232425262728293031323334353637383940414243// 添加一个元素public boolean add(E e) &#123; ensureCapacityInternal(size + 1); // Increments modCount!! elementData[size++] = e; return true;&#125;// 确定容量private void ensureCapacityInternal(int minCapacity) &#123; if (elementData == EMPTY_ELEMENTDATA) &#123; minCapacity = Math.max(DEFAULT_CAPACITY, minCapacity); &#125; ensureExplicitCapacity(minCapacity);&#125;private void ensureExplicitCapacity(int minCapacity) &#123; modCount++; // overflow-conscious code if (minCapacity - elementData.length &gt; 0) grow(minCapacity);&#125;private void grow(int minCapacity) &#123; // overflow-conscious code int oldCapacity = elementData.length; int newCapacity = oldCapacity + (oldCapacity &gt;&gt; 1); if (newCapacity - minCapacity &lt; 0) newCapacity = minCapacity; if (newCapacity - MAX_ARRAY_SIZE &gt; 0) newCapacity = hugeCapacity(minCapacity); // minCapacity is usually close to size, so this is a win: elementData = Arrays.copyOf(elementData, newCapacity);&#125;private static int hugeCapacity(int minCapacity) &#123; if (minCapacity &lt; 0) // overflow throw new OutOfMemoryError(); return (minCapacity &gt; MAX_ARRAY_SIZE) ? Integer.MAX_VALUE : MAX_ARRAY_SIZE;&#125; ArrayList 默认的构造函数，创建的是一个空数组，是在第一次添加对象的时候做的初始化。 添加元素的时候如果容量不足，会进行扩容，新的容量会之前的1.5倍 最大的容量为 Integer.MAX_VALUE 遍历的三种方式ArrayList支持3种遍历方式 (01) 第一种，通过迭代器遍历。即通过Iterator去遍历。 12345Integer value = null;Iterator iter = list.iterator();while (iter.hasNext()) &#123; value = (Integer)iter.next();&#125; (02) 第二种，随机访问，通过索引值去遍历。由于ArrayList实现了RandomAccess接口，它支持通过索引值去随机访问元素。 12345Integer value = null;int size = list.size();for (int i=0; i&lt;size; i++) &#123; value = (Integer)list.get(i); &#125; (03) 第三种，for循环遍历。如下： 1234Integer value = null;for (Integer integ:list) &#123; value = integ;&#125; ConcurrentModificationExceptionAbstractList 中有一个成员变量 modCount, 记录了数据在结构上变化的次数，比如添加或删除一个元素的次数12// The number of times this list has been structurally modifiedprotected transient int modCount = 0; 在Java中的fail-fast机制中有介绍过。在使用迭代器遍历元素的时候，在对集合进行删除的时候一定要注意，使用不当有可能发生ConcurrentModificationException。","categories":[{"name":"java 集合","slug":"java-集合","permalink":"http://yoursite.com/categories/java-集合/"}],"tags":[{"name":"java","slug":"java","permalink":"http://yoursite.com/tags/java/"}]},{"title":"Java Collection 架构","slug":"02-java集合类之Collection 架构","date":"2017-09-07T09:52:03.000Z","updated":"2017-09-14T08:57:04.000Z","comments":true,"path":"2017/09/07/02-java集合类之Collection 架构/","link":"","permalink":"http://yoursite.com/2017/09/07/02-java集合类之Collection 架构/","excerpt":"","text":"概要首先看一下 Collection 的类图结构如下： Collection 是一个接口，它主要有两个分支 List 和 Set。 List 和 Set 是两个接口，他们继承自 Collection ，List 是有序的队列，元素可以重复， Set 是不重复的的集合。 为了减少重复代码，jdk 抽象出了一个 AbstractCollection 抽象类，这个类实现了 Collection 中绝大部分函数，这样在其它的实现类中就可以省去重复的编码。 AbstractList 和 AbstractSet都继承于AbstractCollection，具体的List实现类继承于AbstractList，而Set的实现类则继承于AbstractSet。 Collection 类详解Collection 的定义如下：1public interface Collection&lt;E&gt; extends Iterable&lt;E&gt; &#123; 包含的方法如下： List 详解接口声明： 1public interface List&lt;E&gt; extends Collection&lt;E&gt; &#123; 包含的方法： ![](image:: http://7xo9p3.com1.z0.glb.clouddn.com/markdown/1505118343539.png?imageMogr2/thumbnail/!100p/quality/100!） 其中带 上箭头 是从 Collection 继承来的，相比于 Collection ，主要增加了一些在指定位置添加、删除、修改、获取对应元素的接口。还有获取List中的子队列。 Set 详解接口声明 1public interface Set&lt;E&gt; extends Collection&lt;E&gt; &#123; 包含的方法： 关于API方面。Set的API和Collection完全一样。","categories":[{"name":"java 集合","slug":"java-集合","permalink":"http://yoursite.com/categories/java-集合/"}],"tags":[{"name":"java","slug":"java","permalink":"http://yoursite.com/tags/java/"}]},{"title":"一些好玩的前端项目","slug":"一些好玩的前端项目","date":"2017-07-12T16:00:00.000Z","updated":"2017-09-14T13:03:45.000Z","comments":true,"path":"2017/07/13/一些好玩的前端项目/","link":"","permalink":"http://yoursite.com/2017/07/13/一些好玩的前端项目/","excerpt":"","text":"web 代码编辑器https://ace.c9.io/#nav=howto&amp;api=editor Features Syntax highlighting for over 110 languages (TextMate/Sublime Text.tmlanguage files can be imported) Over 20 themes (TextMate/Sublime Text .tmtheme files can be imported) Automatic indent and outdent An optional command line Handles huge documents (four million lines seems to be the limit!) Fully customizable key bindings including vim and Emacs modes Search and replace with regular expressions Highlight matching parentheses Toggle between soft tabs and real tabs Displays hidden characters Drag and drop text using the mouse Line wrapping Code folding Multiple cursors and selections Live syntax checker (currently JavaScript/CoffeeScript/CSS/XQuery) Cut, copy, and paste functionality web diff工具http://www.mergely.com/doc Mergely is a powerful online diff and merge editor and javascript library that highlights changes in text. It can be embedded within your own Web application to compare files, text, C, C++, Java, HTML, XML, CSS, and javascript. Download Mergely, and refer to the reference manual. Please refer to the the license agreement. Browser-based differencing tool Diff or Merge changes in your own web applications Always available Free and GPLv3 Commercial license available Share diffs online for demonstration or discussion Simple to use Mergely is written with the aid of Code Mirror and jQuery javascript libraries, and uses HTML5 canvas to markup the differences between documents. It will work in most modern browsers. 代码高亮http://codemirror.net/ CodeMirror is a versatile text editor implemented in JavaScript for the browser. It is specialized for editing code, and comes with a number of language modes and addons that implement more advanced editing functionality. Features Support for over 100 languages out of the box A powerful, composable language mode system Autocompletion (XML) Code folding Configurable keybindings Vim, Emacs, and Sublime Text bindings Search and replace interface Bracket and tag matching Support for split views Linter integration Mixing font sizes and styles Various themes Able to resize to fit content Inline and block widgets Programmable gutters Making ranges of text styled, read-only, or atomic Bi-directional text support Many other methods and addons… pdfjshttps://github.com/mozilla/pdf.js/ PDF.js is a Portable Document Format (PDF) viewer that is built with HTML5. PDF.js is community-driven and supported by Mozilla Labs. Our goal is to create a general-purpose, web standards-based platform for parsing and rendering PDFs. JSON Server &amp;&amp; faker.jshttps://github.com/typicode/json-server Get a full fake REST API with zero coding in less than 30 seconds (seriously) https://github.com/marak/Faker.js/ generate massive amounts of fake data in Node.js and the browser 介绍两大神器！——使用json-server和faker.js模拟REST APIhttps://segmentfault.com/a/1190000008574028","categories":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/categories/前端/"}],"tags":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/tags/前端/"}]},{"title":"论工具的重要性","slug":"论工具的重要性","date":"2017-06-14T01:38:30.000Z","updated":"2017-09-14T14:51:14.000Z","comments":true,"path":"2017/06/14/论工具的重要性/","link":"","permalink":"http://yoursite.com/2017/06/14/论工具的重要性/","excerpt":"","text":"最近看了一篇文章:《顶级程序员和普通程序员在思维模式上的5个区别！》 《The Effective Engineer》的作者在写书的过程中，为了了解那些顶级程序员和普通程序员的区别，采访了很多硅谷顶级科技公司的顶尖软件工程师。他发现这些给世界带来巨大影响的的工程师们至少有以下5个共同的思维模式： 1.勇于去研究你不懂的代码 2.精通代码调试(debug) 3.重视能够节约时间的工具 4.优化你的迭代速度 5.系统性的思考方式 其中第三条 重视能够节约时间的工具 带给我很多启发 曾经在Facebook担任技术总监的Bobby Johnson描述过，高效率的程序员都把时间花在制作工具上。很多人也认为工具是很重要的，但是他们并没有花时间去制作、整合自己的工具。但是，Jonson团队最出色的员工耗费了他们1/3的时间在工具制作上，这些工具可以用来发布代码，监控系统，以及能让他们花更少的时间去做更多事情。总之，不要花时间去做机器可以代替你去做的事情。 对于大部分初级工程师来说，大部分的工作内容都是一些重复的业务代码，如果只是被动的编写业务，可能很难有长进，很多人会抱怨整天就是写增删改查的代码，没有技术含量，不能学到新东西，殊不知工作中大部分就是这样的工作。 infoQ负责出品的王概凯写的&lt;&lt;聊聊架构&gt;&gt;第一篇关于生命周期最后有一段话： 非核心生命周期拆分出来成为服务后，这个服务不再仅仅给一个人使用，而变成了所有人能能够共享。非核心生命周期一旦拆分出来后，往往就变成了一个通用的服务，反而获得了更大的生命力，不再局限于原有的大生命周期。对非核心生命周期的掌握，慢慢也就成为了一个一个的职业。而原有的大生命周期则变的更加精简，可以更加专注于自己的核心生命周期活动，以节省更多的时间。 在日常的后台开发中，会有很多通用的需求，是每次遇到复制拷贝一份代码快速实现功能呢，还是可以抽取出一个公共服务或通用的组件提供给大家使用呢？ 假如仅仅为了实现需求，正好自己以前写过类似或则网上有别人的代码，然后自己复制拷贝一份，长远来看其实是一直在做重复的工作，也很难有成长，假如同样的事情做了5遍，10遍充其量你也只是比别人熟练一下而已。 那工作中有哪些是通用的并且是可以抽取出来的功能呢？或者说是非核心生命周期。考虑如下的几个场景： 后台文件导出文件导出是一个通用的需求且很常见，在日常的开发中此类的需求和开发会非常频繁，常见的做法是引入POI的包，从数据库中获取到数据，然后调用POI的接口生成excel文件，输出给浏览器。 需要手工做一次java对象到excel列的映射，如果需求字段有变更，一般情况下需要修改代码上线。 假如导出的数据量特别大，后台也比较耗时，则同步的方式很容易造成超时，一般会做成异步导出，异步下载，则需要很多额外的开发，假如有多个系统都需要，那就需要在多个系统都实现一遍。 假如导出的服务在线上的应用中，大量频繁的导出会请求到数据库主库上，会给数据库造成很大的压力，这个时候需要做读写分离。假如需要占用很多内存，有可能影响线上业务，则需要对导出做服务拆分。 另外还有跨数据库访问的问题。是不是可以在接到这种需求的时候不需要写代码，基于配置式完成功能呢？ 调度系统我们知道java中使用quartz可以很方便的配置定时调度，但是很多定时任务都要求在同一时间只能有一个任务执行。如何保证呢？方法有很多。但是是不是可以提供一个调度系统可以让各业务系统不需要都自己实现一套。 业务监控报警分布式系统中分布式事务问题是一个通用的问题，很难去保证在分布式系统下多个系统的一致性问题，一般业界的通用做法是保证数据的最终一致性。 但是如何发现业务的异常呢？比如订单在支付系统支付成功，但是订单平台支付状态还是未支付。 代码生成在很多的创业公司，或中小型项目开发的公司，会面临大量新系统的开发，每次搭建项目的基础代码都会非常耗费时间，而且里面有大量的配置文件和配置项。如何快速生成项目模板，省去基础的框架配置呢？ 以上的四个场景在我们当前的公司都有独立的系统和工具去支撑对应的需求，每一个系统在不断的迭代过程中都焕发了自己更强大的生命力。","categories":[{"name":"随笔","slug":"随笔","permalink":"http://yoursite.com/categories/随笔/"}],"tags":[{"name":"工具","slug":"工具","permalink":"http://yoursite.com/tags/工具/"}]},{"title":"jsonp 解决跨域请求","slug":"jsonp解决跨域请求","date":"2017-01-12T01:08:28.000Z","updated":"2017-09-14T14:16:44.000Z","comments":true,"path":"2017/01/12/jsonp解决跨域请求/","link":"","permalink":"http://yoursite.com/2017/01/12/jsonp解决跨域请求/","excerpt":"","text":"http://api.jquery.com/jQuery.ajax/ javascript1234567891011121314$.ajax(&#123; type: &quot;get&quot;, async: false, url: &quot;http://wukong.iqdnet.cn/wukongbg/admin/monitorList/test&quot;, dataType: &quot;jsonp&quot;, jsonp: &quot;callbackparam&quot;,//传递给请求处理程序或页面的，用以获得jsonp回调函数名的参数名(一般默认为:callback) success: function(json)&#123; console.log(json); alert(json); &#125;, error: function()&#123; alert(&apos;fail&apos;); &#125; &#125;); 服务器端 首先 123456789101112131415161718192021/** * test */@RequestMapping(value = &quot;test&quot;,method= RequestMethod.GET)@ResponseBodypublic Object test(String callbackparam,HttpServletRequest request,MonitorListParams monitorListParams) &#123; logger.info(&quot;find monitorList list.&quot;); System.out.println(System.getProperty(&quot;env&quot;)); ModelResult modelResult = new ModelResult(ModelResult.CODE_200); ResultPage&lt;MonitorList&gt; resultPage = null; resultPage = monitorListService.getResultPage(monitorListParams); modelResult.setMessage(&quot;查询成功&quot;); modelResult.setResultPage(resultPage); String content = JSON.toJSONString(modelResult); content = callbackparam +&quot;(&quot;+content+&quot;)&quot;; return content;&#125;","categories":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/categories/前端/"}],"tags":[{"name":"jsonp 跨域","slug":"jsonp-跨域","permalink":"http://yoursite.com/tags/jsonp-跨域/"}]},{"title":"HashMap 详解和源码解析","slug":"06-深入研究java基础---HashMap","date":"2016-10-21T10:12:53.000Z","updated":"2017-09-14T08:31:51.000Z","comments":true,"path":"2016/10/21/06-深入研究java基础---HashMap/","link":"","permalink":"http://yoursite.com/2016/10/21/06-深入研究java基础---HashMap/","excerpt":"","text":"概述123public class HashMap&lt;K,V&gt; extends AbstractMap&lt;K,V&gt; implements Map&lt;K,V&gt;, Cloneable, Serializable 类图结构 http://yikun.github.io/2015/04/01/Java-HashMap%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86%E5%8F%8A%E5%AE%9E%E7%8E%B0/ http://www.cnblogs.com/skywang12345/p/3323085.html","categories":[{"name":"java 集合","slug":"java-集合","permalink":"http://yoursite.com/categories/java-集合/"}],"tags":[{"name":"java","slug":"java","permalink":"http://yoursite.com/tags/java/"}]},{"title":"java 集合类概述","slug":"01-java集合类概述","date":"2016-08-05T03:58:13.000Z","updated":"2017-09-14T08:32:09.000Z","comments":true,"path":"2016/08/05/01-java集合类概述/","link":"","permalink":"http://yoursite.com/2016/08/05/01-java集合类概述/","excerpt":"","text":"在java中一切皆是对象，集合就是盛放对象的容器，根据不同的数据结构（集合、链表、队列、栈、数组、映射等）对应不同的集合类。java的集合类都在java.util包下。为了处理多线程环境下的并发安全问题，java5还在java.util.concurrent包下提供了一些多线程支持的集合类。本文暂不包含并发集合包。 java 集合主要可以分为如下4个部分：List列表、Set集合、Map映射和工具类（Iterator迭代器、Enumeration枚举类、Arrays和Collections）。如下图所示： 整体的框架图如下： 梳理出主干我们常用的集合类如下： 最主要的两个接口 Collection 和 Map 1 、 Collections 包含了 List 和 Set 两种不同的数据集合。 List 是一个有序的队列，包含了常用的 ArrayList，LinkedList、Vector和Stack 类。 Set 是一个不允许重复元素的集合，包含有 HashSet、TreeSet。HashSet依赖于HashMap，TreeSet依赖于TreeMap 2、 Map 是表示键值对映射的结构。 AbstractMap 是一个抽象类，它实现了Map接口中的大部分API，而HashMap、TreeMap、WeakHashMap都是继承于AbstractMap。HashTable继承于Dictionary，但它实现了Map接口。 Arrays 和 Collections 是两个常用的工具类。","categories":[{"name":"java 集合","slug":"java-集合","permalink":"http://yoursite.com/categories/java-集合/"}],"tags":[{"name":"java","slug":"java","permalink":"http://yoursite.com/tags/java/"}]},{"title":"我的读书史","slug":"我的读书史","date":"2016-03-14T08:48:02.000Z","updated":"2017-09-14T10:31:19.000Z","comments":true,"path":"2016/03/14/我的读书史/","link":"","permalink":"http://yoursite.com/2016/03/14/我的读书史/","excerpt":"","text":"一本好书，往往一开始会读的特别快，临到最后反而舍不得读完。读罢，故事里面的人和事，萦萦于脑畔，飘着飘着，慢慢的尘封于一处。 启蒙小的时候可供娱乐的东西很少，不像现在的小孩子在2、3岁的时候，父母就会给孩子买一些绘本启蒙，我是到了小学认字之后才开始看一些”课外书“，而且当时可供阅读的书也很少，好的书就更少了。 小学四五年级的时候，同学中开始流传一些课外书，比较正统的《格林童话》《安徒生童话》《一千零一夜》《十万个为什么》《伊索寓言》，大都是需要借同学的看，我看书比较快，这些书很快就看完了，看的多了发现很多神话故事框架大都很相似，那个时候自己无聊也会给妹妹编一些神话故事听。 那个时候学校里还流传着一些《故事会》《鬼故事》《十八层地狱》之类的一些书，书不大也很薄，一本书大约5毛钱的样子，大都是一些员外，书生小姐，妖狐之类的故事。当时也是饥不择食，几乎什么都看，当然这些书看的时候不能被大人看见，所以只能偷偷的看，有时候看的入迷到了晚上就拿手电筒躲在被窝中看书，所以导致现在眼睛近视加散光，离开眼镜整个世界都是模糊的。 即使这样仍然还是会有没书看的时候，记得以前的日历上每页都会有一些小故事，所以也会找些日历来看，报纸的中缝也会有很多小故事，自己也会拿来看，伯父家里有订阅的报纸，有时候去伯父家的时候，也会拿报纸过来找里面的故事看。 后来大伯父发现了我喜欢看书，当时他在我们小学当校长，暑假的时候就帮我从学校图书馆借了一些书回来。然后我就看到了一些传纪类的书《小兵张嘎》《铁道游击队》还有一些国外的故事书，名字不太记得了，但是故事都很好，印象比较深的是有一个是把玻璃的知识写到了一个童话故事中。如今伯父因为一次意外已经不在了，想来不胜伤感。 成长上了初中可以看得书籍开始变多了，语文老师也会鼓励大家看一些优秀的名著。这个阶段陆续看了《朝花夕拾》《骆驼祥子》《鲁滨逊漂流记》《格列佛游记》《家春秋》《四世同堂》《老人与海》等一些书，很多书看得并不太懂，当时看这些书大多只是因为他们是名著吧，不知道现在再读会有什么新的感想。 所幸爸爸妈妈并不怎么限制我读课外书，有时还会主动给我买一些，陆续让爸妈给买了四大名著来读《西游记》《水浒传》《三国演义》《红楼梦》，当时最喜欢的是《三国演义》，读罢写了一篇作文《蜀相》参加作文比赛获得了二等奖。 初中因为离家比较远，开始住校了，也开始有了自己的零花钱，然后每隔一两个星期我就会去学校的书店买课外书看，有时候和同学约着分别买不同的书，换着看。 这个时候开始迷上了金庸古龙，飞雪连天射白鹿，笑书神侠倚碧鸳，整个初高中，把金庸的小说看了不止一遍。古龙的小说风格和金庸完全不一样，然后数量也更多，印象比较深的有《楚留香传奇》《小李飞刀》《大地飞鹰》《流星蝴蝶剑》《七种武器》《陆小凤传奇》等，看的很多，忘得也多。千古书生侠客梦，金庸古龙伴随着他们给我们创造的武侠世界，应该也是70、80年代的一个整体时代记忆吧。 记得班上有一本韩寒的《三重门》，读完之后特别想读韩寒其它的书，由于没有买到，只得作罢。 初中的宿舍一晚上都不熄灯，我正好在上铺，灯下面，很多书都是趴在床上看完的，还得时刻提防查宿的老师。 高中以前的暑假是读书最好的时光，我家自小便没有地，下午的时候，搬一把椅子，坐在阴凉地，一读便是一整天。 这个时候也开始看一些历史传记，从哥哥家找来的《隋唐演义》《杨家将》《齐白石传》《周恩来传》《洪武皇帝朱元璋》等，上下五千年，瀚如烟海。 高中高中到了泰安去上学，自己能掌握的生活费更多了，然后也就有了更多的钱去买书看，从我们学校往西走有一个夜市，有一些卖书的书摊，大部分都是一些盗版的书，合集比较多，一本书很厚，字也特别小，但是对于学生来说价格相对合适，我在那边买过很多，由于大部分是盗版，大部分书到现在也都遗失了。 初中想读而没有读到的韩寒和郭敬明也是在这里买的，读了《三重门》《零下一度》《通稿2003》《梦里花落知多少》《幻城》《夏至未至》，不一样的作者，不一样的文字，不一样的人生，也讲述不一样的故事。而今郭敬明做了导演，吸金无数，韩寒做了赛车手。匆匆十几年，弹指一挥间。 这个时候也开始接触了一些外国文学，《巴黎圣母院》《茶花女》《双城记》《堂吉诃德》，最喜欢的当属《基督山伯爵》，快意恩仇，执剑江湖。 我读书读完一本，如果喜欢就会找这本书作者的其它书来读，一本好书，往往一开始会读的特别快，临到最后反而舍不得读完。读罢，故事里面的人和事，萦萦于脑畔，飘着飘着，慢慢的尘封于一处。 语文老师上课的时候给我们推荐了余华的《活着》，读完思绪良久，又买了一本余华文集，然后读了《许三观卖血记》《在细雨中呼喊》。然后从这开始喜欢看一些近现代文学。 张爱玲的《半生缘》《金锁记》《倾城之恋》，看张爱玲的文字很容易被吸引，穿越时空回到那个时候的旧上海去旁观一个又一个的故事，在书中演绎着一个又一个各自不同的人生。 余秋雨的《千年一叹》，看余秋雨的书感觉就很博学，总是能看到很多自己不知道的东西。 巴金的《家春秋》，这三本书读起来和《红楼梦》是有一点像的，都是大家族的盛衰，看到最后沧海桑田，世事变迁。其实每个人又何尝不是如此，如今每次回老家，路过破败的老屋，看到已经不属于自己的新屋，再也找不回的儿时伙伴，心里也不胜感叹。 《红楼梦》应该是我最喜欢的文学类书籍，最早接触是在初中，当时并没有看完，高中的时候看完了一遍，深陷其中，又读了刘心武的《刘心武揭秘红楼梦》周汝昌关于红学的系列书籍，记得还有一本《红楼真梦》，高中语文课老师让同学上去分享四大名著，我便上去分享了《红楼梦》不同于其它同学，讲了一些红学和曹雪芹特殊的写作手法，备受老师和同学的赞赏。毕业后来了北京，找了个周末去了趟北京的大观园，可惜很难和书中的大观园产生共鸣。直到现在，每隔几年都会重读一次红楼梦，每次又都有新的收获，看到不同的版本，总会有收藏的欲望。最近在看白先勇老师的《细说红楼梦》，收货颇多。 贾平凹的《废都》《高老庄》，贾平凹的文字当时读不太懂，也不是特别吸引，我所以就只看过这两本，硬着头皮看，讲的什么现在也都记不得了。 《穆斯林的葬礼》是我非常喜欢的另外一本书，不同于其他书籍的叙事风格，带你走进一个穆斯林的世界。 三毛的作品也是在这个时候接触，《哭泣的骆驼》《沙哈拉的故事》《梦里花落知多少》，到后来大学毕业买了三毛全集，三毛的文字总能带给我很多感动，娓娓道来，没有太多华丽的语言却都很真实。现在仿佛感觉她还是一个人在流浪着。 高中的作文如果写的不错会被老师印做范文，在级部中讲评，我的几篇作文也被老师选中，可惜原文都没有留下来了。当时的周记也都遗失了。 大学我们大学的图书馆建的非常漂亮，曾获得过鲁班奖，整体圆弧形的设计，从前面看像一本展开的书页，图书馆的前面是人工湖，后面是大片的草坪。我当时很喜欢去图书馆借书看，说实话，文学区好书并不是很多，大部分很旧，而且热门的书籍通常借不到。偶尔遇到一本，我也很少借出去，大都是一读起来便停不下了，从上午看到晚上，一本书也差不多就看完了。 初读《平凡的世界》对我的人生观和价值观都产生了很大的影响，相逢恨晚。少平的经历或多或少给我了我很多勇气，促使我在那些独自学习的夜晚，虽然看不到未来的方向，依然默默的坚持。 莫言的书也是在这个时候看的，当时莫言还没有得诺贝尔奖，记得有次去我们学校开讲座。《红高粱》《檀香刑》因为讲的是山东的故事，所以有些时候也倍感亲切。 高中以前买的书大部分都是盗版的，而且很多都是合集，字特别小，看的时间长很毁眼睛。大学的时候开始用手机看电子书，看的书类型也更广了。 大学看技术书和专业书相对多一点，其它就是为了消磨时间看了一些《鬼吹灯》等热门的网络文学。 毕业之后初读东野圭吾又是另外一片天地，最早读的《嫌疑犯X的献身》而后看了《白夜行》《解忧杂货铺》都能带来不一样的体验。 最早知道刘心武是高中读《红楼梦》的时候，当时买了很多研究红楼梦的书，而后看了《钟鼓楼》，由于是在北京，听着书中娓娓道来的后海，随着时间的流逝，感受北京和历史的厚重。 《读库》最早是在大学实验室接触的，最早的一本读库是刘老师拿到实验室的，而后一发不可收拾，如今大半个书架都摆满了读库出品的各种书。编剧张立宪江湖人称六哥，十年间不忘初心。 沈复的《浮生六记》一本小书，读过之后感触颇深，现存的总共只有四篇，读的文言文原版，最近出了一本白话版的，读起来却很难有古文的感觉，所以还是推荐读原文。 齐邦媛的《巨流河》一部家国苦难史，战争，苦难，时代变迁，沧海桑田，斗转星移。 野夫的书风格又是不一样，有着江湖人的豪迈，还有那个时代无需过多渲染就能打动人的人和事。《乡关何处》《身边的江湖》《1980年代的爱情》每一本书都值得一看。 柴静的《看见》，媒体人的语言，不带个人情感的给我们讲述她所看见的。很喜欢柴静的人和文字，后来发现读库每年的见面会六哥都会请柴静去做主持，一直想去趟现场，结果到现在也没有去成，而今柴姑娘已经不主持了。 最近一两年看了一些最近出的书《人类简史》《未来简史》是少有的值得推荐给其它所有人的书。读过《人类简史》感觉不过瘾又找来了《枪炮、疾病与革命》。 吴晓波的新书《腾讯传》读来会感觉到我们正在经历着最近的历史，或则你也能在创造者历史，十几年的时间，腾讯的发展历程，其中的波折和故事，又有几个人能讲的清全貌。 而后看了吴军老师三册的《文明之光》，感叹人类生命在整个浩瀚宇宙之渺小，整个人类历史又是如此短暂。近现代文明对文艺复兴有了更深刻的认识，也想更多的去了解关于那段历史。 最近买了威尔杜兰特的《世界的文明》，一个人50年，不知道何时自己可以读完。 后记大部分是文学书的一些记忆，很多书在历次搬家中都遗失掉了，有时候记起来读书的过程也是一段美好的记忆。","categories":[{"name":"随笔","slug":"随笔","permalink":"http://yoursite.com/categories/随笔/"}],"tags":[{"name":"读书","slug":"读书","permalink":"http://yoursite.com/tags/读书/"}]},{"title":"意料之外的大雪","slug":"snow","date":"2013-03-19T16:00:00.000Z","updated":"2017-09-14T10:43:48.000Z","comments":true,"path":"2013/03/20/snow/","link":"","permalink":"http://yoursite.com/2013/03/20/snow/","excerpt":"","text":"进入三月，北京的天气本来已经开始转暖，屋里的冷气也在这几天停止了供暖，有几天气温已经接近二十度，没想到从昨天中午开始，天却起了大雪，说是鹅毛大雪倒也不为过，下午下班的时候还在下雨加雪，我因为没有带伞，所以想等着小一点再走，一直到晚上8点反而越下越大。找了把同事的旧伞，凑合还可以用，就出门准备回去了，路上行人仍然不少，都是行色匆匆，估计都是下班往家里赶的人。我平时都是走路回家，大约30多分钟，今天由于天气不怎么好所以就坐公交回去，等车的时候一个女孩也没有带伞，一直在打电话。 今天早上起来推开门，才发现路上竟然积起了20厘米左右的雪，雪很白很软，树上挂满了晶光闪闪的雪花，一片银装素裹的世界。很多人在路边拍照，倒有了一种寒冬初雪的气氛。 已经有好多年不曾看到很厚又很白的雪，特别是最近很多年在外求学，大都是在城市里面，下雪的时候要么雪量很少，要么下了也就化掉了，要么就是根本没有时间和心情去外面赏雪玩雪。 上大一的时候，南方来的同学大都很期待冬天快点到来，因为可以看到雪，有些人可能从小到大都没有见过雪的世界是什么样子。不过那一年虽然雪也下了，但是赶上了多年不遇的大雪灾，南方受灾更为严重，过年回家家里下的雪一点也不比北边要少。记得我坐长途客车回去路上遇上好几个事故。 走在去公司的路上，还不是上班高峰，洁白的雪，踩上去沙沙作响，突然间就希望把自己想象成10几年前小学的时候下雪天去学校的场景，那时候天一下雪学校就会广播，让离家近的同学回家拿扫雪的工具，整个学校也开始集体大扫除，本是少年爱玩的年纪，扫雪的时候大家便免不了打打闹闹，然后校园里就会多上几个大雪堆和奇形怪状的雪人。记忆中那个时候天总是很蓝，雪也是洁白洁白。 不像城市，农村里面大片的农田，冬天下雪后很难化掉，一般会保留很长一段时间，极目望去，远山和一望无际的原野，到处都是洁白的雪，置身与其中，别有一番意境。 最近北京雾霾的天气越来越多，走在街上呼吸的空气都有一种沉重感，每次雨雪或大风过后空气会恢复过来一点，再隔一两日则又会变成昏昏暗暗的天气，真的希望有时候人可以慢一点下来，看看路边的风景，品味下静静的生活。","categories":[{"name":"随笔","slug":"随笔","permalink":"http://yoursite.com/categories/随笔/"}],"tags":[{"name":"大雪","slug":"大雪","permalink":"http://yoursite.com/tags/大雪/"}]},{"title":"追忆似水流年","slug":"childhood","date":"2013-03-11T16:00:00.000Z","updated":"2017-09-14T12:38:54.000Z","comments":true,"path":"2013/03/12/childhood/","link":"","permalink":"http://yoursite.com/2013/03/12/childhood/","excerpt":"","text":"现在回想起来，儿时的记忆真的是最值得珍藏的一段时光，很多东西也都已经模糊不全，留下的只有一些片段，几点画面，但即使如此，淡忘的或许永远想不起，而留下的也将一直记着无法抹去。 西池塘小时候居住的村子叫“李所村”，地处丘陵，两面环山，村子的西边有一个很大的池塘，有一口很大的泉眼，据说是从北面山上过来的水源，夏天汛期水量尤足。向南则一条小河首先向东，途径学校，直贯南北，流经村中间的时候又有几眼泉，清而洌，水质自然也是极好，河边一口老井，方一平有余，石砌而成，深不足十米，经年不曾干涸，村中人多半饮此水为生，或挑或担，或用水车，每逢朝晚，络绎不绝。 河边多树，夏日凉风习习，绿影斑驳，多有姑婆河边洗衣，家常里短，喧闹声不绝于耳。几多顽童，嬉与水间，捕鱼戏水，无不尽兴而归，全身尽湿。 村里人管东西朝向的这一段小河叫做“下沟”，沟的北面则称为“沟北沿（崖）”，我的家便在村子的最北边，本是多年老屋，大部分的石头都不是整块的，听奶奶说是当时爷爷一点一点捡碎石垒起来的。后来大约上三年级的时候就在村子的东边盖了后来的新房子，之前的老屋也拆掉了。 苹果园村子的北边是一条水渠，顺着水渠的方向则是大片的苹果园，姑姑家跟我们在一个村里，那个时候姑姑家里承包了其中的一片苹果园，有的时候我就会和儿时伙伴一起去那个地方玩耍，现在想来，倒留下很多记忆。每年的四五月份是苹果开花的季节，很淡雅的白色，微带一些红色，置身与其中，微风阵阵，一股清香，自有一番乐趣。 苹果大约在10月份左右成熟，苹果快成熟的时候就需要有人看着，防止有人偷，在苹果园里有一间屋子，平时的时候表哥会在那边看苹果园，有些时候我也会过去，游荡与满是果子的果园，又红又大的苹果触手可及。很难想象一棵苹果树怎么会结那么多果子，很多枝条被压的弯弯的。快成熟的时候，一个个红红的苹果，甚是惹人喜欢。 收苹果的时候，尤其热闹，很多人会来帮忙。诺大的苹果园仿佛进了王母娘娘的蟠桃园，红红的果子挂满枝头，在太阳下面闪着金灿灿的光。苹果按照个头大小被分别装箱，装车，运向不知道哪里的远方。 清明春游春天，万物复苏，新芽初生。小学的时候，每逢清明节，学校每年都会组织去烈士扫墓，大约提前一个多月就要准备，学校的仪仗队也会开始训练，敲鼓的、打镲的、吹号的还有举旗的，好生威武。如果能被选入仪仗队，都会被同学们羡慕。除了仪仗队的同学，其他人就要忙着训练赞歌。 等到出发的那天，大家排好队，两人一排，便浩浩荡荡的出发了，我们那个时候上学的人多，队伍都能排出两三里路。会时不时的看到有些“传令兵”小跑着传递消息，颇有些战时行军的味道。 因为是春游，午饭是要在外边解决的，吃饭的时候大家拿出各自准备的食品，分而食之，多有一番乐趣在其中。 野味在农村，地里的很多东西都是可以吃的，比如野菜、蚕蛹、蚂蚱。春天，万物复苏，路边的榆树长出榆钱，路边开出野花，长出嫩绿的野菜苗，荠菜、蓬蓬菜采一些，即使用最原始的做法，也相当的可口，最近再会老家问起家里的老人还吃么，都说大部分都有农药不敢吃了，而且村里也少了小时候的那份闲适。父辈们都在外打工，祖辈们大多年龄都大了。 收麦子在我上小学的时候我们还有“麦假”，大约一个多星期左右，因为到了麦子成熟的季节，学校的老师家里也大都有地，需要回家收麦子，然后便会给我们放假。 这个时候山上的桑葚正好成熟，和同学结伴去山上采一些，算是很好的果子了。 夏日乘凉小的时候，村子里的电视还不是特别多，每到夏天傍晚的时候，日头渐落，大家就会走出家门来到外边乘凉。有的搬一个凳子，有的拿一床凉席，手里拎一个大蒲扇，夏天由于是刚收完麦子，村里的场还没有撤掉，所以会有很多开阔的地方，地也很平整，特别适合乘凉。 邻里拉拉家常，儿童追赶嬉闹，天上的星星很多，记忆中的月亮也是又大又圆。 打牌山东人是比较喜欢打牌的，小到五六岁小孩，老到五旬老人都能够在夏日午后围坐一起，打牌聊天，可能农村的娱乐活动本来就少。我说的牌就是指纸牌，玩的花样也很多，比如入门级的“拖拉机”（“也叫排火车”），再有最常玩的”升级“，以及”保皇“”够级“，每一种玩法除了需要的人数不同，规则也是不同，所需要的牌数也不同。 小学的时候一到放寒暑假我三姑家的表哥就会来我家这边住，那时候似乎大家都很有时间，哥哥们也都在家，很容易就凑够五六个人，一起围坐一起打牌也成为那时候的一件乐事。现在除了过年大家还都会回家，再围坐一起的机会越来越少，每个人也都有了自己的家庭，也都有了孩子。 游戏机最早见过的游戏机还是表哥用弹珠“换”来的，只能玩俄罗斯方块，躲障碍之类的游戏，但是当时也玩的不亦乐乎，再后来有一天大伯父家的堂哥拿来了一个能插卡玩游戏的学习机，才第一次玩到了双截龙之类的游戏，之后便久久不能忘，过了段时间便让爸妈给买了一个那时叫“小霸王”的学习机，也算是我们80年代孩子的一个时代记忆吧。那时候在学校除了交流游戏心得，便是打听谁有新的游戏卡然后互相交换玩，“魂斗罗”“超级玛丽”“雪人兄弟”“冒险岛”“影子传说”“坦克大战”，每一个名字现在听起来还是那么有亲切。 那时候玩游戏经常是一玩一天，只能两个人一起玩，有时候人多的时候就会交替着玩，谁输了谁就下。差不多过关的游戏都会想办法通关，还记得和表哥一起把魂斗罗通关，五爷爷喜欢玩坦克，那时候我们爷俩可以玩一整天，不知爷爷是否还记得。 小学在我四年级之前还仍然在村里的小学上学，叫“李所小学”，原本是德国人在1910年左右建的教堂，在村子的最中心的位置，大小有几十间房子，有很大的院子，课件的时候异常热闹。 后来我上四年级的时候再村子的东边建了“东平成才希望小学”，有两座2层和一座3层的教学楼。这个学校是一个华侨赞助创建的，记得刚成立的时候还给我们学校的每个同学发了棉衣，文具。","categories":[{"name":"随笔","slug":"随笔","permalink":"http://yoursite.com/categories/随笔/"}],"tags":[{"name":"小时候","slug":"小时候","permalink":"http://yoursite.com/tags/小时候/"}]}]}